- Jak dzia³a animowany tekst?
Tworzymy obiekt z prefaba, a nastêpnie wywo³ujemy funkcjê setText. Funkcja ta przyjmuje stringa i opcjonalnie wielkoœæ czcionki, po³o¿enie.
Nastêpnie ka¿dy znak dopasowuje do danego typu (ma³e litery/du¿e/liczby/symbol itp.), oraz tworzy tablicê o rozmiarze stringa, przypisuje jej liczby od 1 do rozmiaru i miesza j¹ -> to potem bêdzie u¿yte do usuwania znaków w losowej kolejnoœæi.
W FixedUpdate odbywa siê animacja - ka¿dy znak jest zmieniany iloœæ 'step'. Nowy znak dodawany jest, gdy poprzedni znak jest w po³owie losowania step-razy. Po animacji wszystkich znaków uruchiomona jest funkcja EmptyText.
EmptyText czeka 2 sekundy i zale¿nie od d³ugoœci tekstu iteruje usuwanie znaków (im d³u¿szy tekst, tym czêstotliwoœæ klatek jest wy¿sza). Usuwa znaki losowo wed³ug wczeœniej wspomnianej wymieszanej tablicy.

- Jak dzia³a Stat
Jest to uniwersalna klasa pozwalaj¹ca na bezpieczne operowanie zmiennymi numerycznymi. Bezpieczne, bo nie pozwoli na przekroczenie zera, ani ustalonej wartoœci maksymalnej. Jest ona kompatybilna z klas¹ BarPrototype

- Jak dzia³a BarPrototype
Do ka¿dej klasy Stat mo¿liwe jest do³¹czenie paska. Mo¿emy ustaliæ szybkoœæ uzupe³niania paska, kolor przechodzenia paska a la gradient, oraz stringa, który poka¿e wartoœæ. Z ka¿d¹ zmian¹ wartoœci w klasie Stat uruchamiany jest set z Value, który ustala do ilu ma zeskalowaæ pasek. W metodzie Update wykonywane jest p³ynne uzupe³nianie/odejmowanie paska.

- Jak dzia³a kamera?
Pozycja kamery to zawsze x -> pozycja gracza, y-> pozycja gracza + offset, z-> pozycja kamery. W metodzie update co klatke sprawdzany jest dystans miêdzy pozycj¹, w której powinna byæ kamera, a pozycj¹ w której jest. Jeœli dystans jest wiêkszy ni¿ wartoœæ deadZone, to nastêpuje p³ynne przybli¿enie (Lerp).

- Jak dzia³a GameMenusHandler (czyli otwieranie poszczególnych menu)?
£opatologicznie - Na przycisku escape zamykamy jakiekolwiek menu jest teraz otwarte, ale jeœli ¿adne nie jest, to otwieramy PauseMenu. Na przycisku B otwieramy menu ze skillami, jeœli ¿adne inne menu nie jest otwarte, b¹dŸ jeœli otwarte jest menu ze skillami, to je zamknij.

- Jak dzia³a menu ze skillpointami.
Metoda awake - przypisanie wszystkich obiektów z menu do zmiennych i stworzenie AudioSource, aby odgrywaæ dŸwiêki przy klikaniu przycisków/najechaniu na skilla. Dodane s¹ listenery do przycisków do rozdawania pkt umiejêtnoœci.
 
Metoda OnEnable - przy otwarciu menu aktualizujemy wszystkie statystyki i w razie, gdy gracz ma punkt umiejêtnoœci, to mu to poka¿ i w³¹cz przyciski do dodawania skillów. Jeœli nie ma punktów, to wy³¹cz przyciski dodawania.

Metoda addSkillPoint - po dodaniu skilla odgrywamy dŸwiêk, inkrementujemy wartoœæ skilla, aktualizujemy tekst i dodajemy moc zwi¹zan¹ ze skillem. Jeœli gracz po dodaniu ma 0 pkt umiejêtnoœci, to wy³¹cz przyciski.

- Jak dzia³a podœwietlanie skillów i zmiana opisu w menu?
Do ka¿dego t³a skilla dodany jest skrypt SkillHover. Ten skrypt tworzy AudioSource dla danego przycisku i pobiera tekst jaki jest w opisie przed najechaniem. Przy najechaniu na t³o odegrany jest dŸwiêk, zmieniony tekst na ten z inspektora oraz zmieniona przezroczystoœæ na maksa. Po wyjœciu z t³a zmieniony tekst jest na ten przed najechaniem i t³o zmienione na domyœlne.

- Jak dzia³aj¹ delegaty œmierci?
Delegat to lista funkcji wywo³ywana w danej kolejnoœci. Upraszcza to modyfikacjê kodu. Delegat jest typem, tak jak int, czy string, ale w tym przypadku to bardziej tablica. Do delegatu dodajemy drop, funkcjê zniszczenia przeciwnika oraz wywo³anie funkcji dla gracza.

- Jak dzia³a poruszanie?
 Poruszanie podzielone jest na 2 skrypty - ThirdPersonUserController i ThirdPersonCharacter. Ten pierwszy ma za zadanie wczytywaæ klawisze i przekszta³ciæ je na zmienne, które bêd¹ u¿yte w tym drugim (funkcja Move).
Funkcja move przyjmuje trzy zmienne - wektor move, czyli to, w któr¹ stronê siê mamy poruszaæ, bool crouch, czyli czy gracz naciska klawisz C i bool jump, czy gracz skacze.
Funkcja ta na pocz¹tku przekszta³ca wektor z inputu do wektora dla postaci. Potem sprawdza, czy jest na pod³odze spherecastem w dó³, a nastêpnie zale¿nie - jak jest na pod³odze, to uruchamia funkcjê HandleGroundedMovement, albo HandleAirborneMovement.
HandleGroundedMovement ma za zadanie sprawdzenie, czy gracz mo¿e skoczyæ i jeœli chce skoczyæ, to nadaje velocity y na si³ê wyskoku.
HandleAirborneMovement ma za zadanie obs³ugê lotu gracza. Pobiera input, aby w locie kontrolowaæ kierunek, a potem nadaje grawitacjê.
W movement na koñcu w razie kucania wywo³ana jest funkcja skurczania kapsu³y (mniejszy collider) oraz UpdateAnimator - czyli przes³anie danych do animatora o tym jak siê gracz porusza, aby pokazaæ dobr¹ animacjê.

- Jak dzia³a celowanie?
W skrypcie ThirdPersonCharacter odpowiedzialne za to s¹ metody - HandleRotation, HandleAimingPos i HandleShoulder. Na starcie przypisujemy komponenty do zmiennych, zamra¿amy wiêkszoœæ wektorów poruszania siê w rigidbody i dodajemy obiekt pomocniczy do pozycjonowania broni. HandleRotation obraca ca³ego gracza w zale¿noœci od pozycji myszki. HandleAimingPos pobiera pozycjê myszki (odbija raycastem pozycjê 2d na planszê 3d). HandleShoulder obraca broni¹.
IKHandler ma za zadanie ruszania ramionami. Pozycja do której ma siêgaæ ustala wczeœniej wspomniania metoda HandleShoulder.
 
- Jak dzia³a dŸwiêk poruszania siê?
Obiekt Jump i Footstep dodano do gracza. Odg³os l¹dowania odgrywany jest, gdy gracz jest na ziemi, a klatkê wczeœniej nie by³. Odg³os chodzenia odgrywany jest, gdy gracz naciska klawisz shift. Biegania, gdy biega.






